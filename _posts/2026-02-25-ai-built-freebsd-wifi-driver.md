---
layout: post
title: "AI 帮我写了一个 FreeBSD Wi-Fi 驱动：这才是 AI 编程的正确打开方式"
date: 2026-02-25
author: Cobb
categories: [AI, 编程]
tags: [AI编程, FreeBSD, 驱动开发, Claude]
pin: false
---

昨天 Hacker News 上一篇文章火了——一个开发者用 AI 为自己的老款 MacBook 写了一个 FreeBSD Wi-Fi 驱动，拿到了 400 多个赞。这个故事之所以吸引我，不是因为「AI 又能干啥了」，而是它展示了一种**非常务实的 AI 编程模式**。

## 故事背景

作者 Vladimir Varankin 有一台 2016 年的 MacBook Pro，想装 FreeBSD 玩玩。问题是，这台机器用的 Broadcom BCM4350 Wi-Fi 芯片，FreeBSD 原生不支持。社区的常规方案是跑一个 Linux 虚拟机来管理 Wi-Fi——能用，但不优雅。

他的想法很简单：Linux 已经有现成的 brcmfmac 驱动（ISC 协议），FreeBSD 也有 LinuxKPI 兼容层来运行 Linux 内核驱动。理论上，只需要把一堆「胶水代码」从 Linux 移植到 FreeBSD 就行了。

听起来不复杂，但实际操作中涉及大量枯燥的 API 适配工作——正是 AI 最擅长的领域。

## AI 干了什么，没干什么

这个故事最有价值的部分，不是 AI 「自动生成了一个驱动」，而是人和 AI 之间的分工模式：

**AI 擅长的部分：**
- 大量的 API 映射和适配代码（Linux → FreeBSD）
- 根据已有驱动模板生成框架代码
- 快速迭代修复编译错误

**人必须做的部分：**
- 理解整体架构和移植策略
- 判断哪些代码路径是关键的
- 调试运行时的硬件交互问题
- 做最终的质量把关

作者用了 Claude Code 来完成初始移植，让 AI 参考 FreeBSD 中已有的 iwlwifi 驱动（同样是从 Linux 移植过来的），按照类似的模式生成 brcmfmac 的 FreeBSD 版本。

## 这给我们什么启示

### 1. AI 编程的甜区是「已知模式的大规模应用」

写驱动移植代码，本质上是一个模式匹配问题：看 Linux 怎么做的，看 FreeBSD 的惯例是什么，然后逐个适配。这种工作人类做起来极其枯燥且容易出错，但对 AI 来说只是「参考 A，输出 B」。

### 2. 冷门领域反而更能体现 AI 的价值

FreeBSD 内核驱动开发是一个极其小众的领域，相关资料少、社区小、找人帮忙难。但正因为如此，AI 的辅助价值反而更大——它不需要这个领域有大量训练数据，只需要理解代码的结构和语义。

### 3. 最终产出的质量取决于使用者

同样的工具，一个不懂内核开发的人用 AI 生成的驱动代码大概率跑不起来。作者之所以能成功，是因为他有足够的背景知识来**引导 AI 的方向**和**验证 AI 的输出**。

## AI 编程的务实主义

市面上关于 AI 编程的讨论，要么是「AI 马上替代程序员」的焦虑论，要么是「AI 写的代码都是垃圾」的否定论。这个 FreeBSD 驱动的案例提供了一个中间视角：

**AI 是一个极其高效的代码搬运工。** 它不会替代你思考架构，但它能把你脑子里的方案以 10 倍速度落地。前提是——你得真的知道自己在做什么。

这和我们日常开发中的体验完全一致。AI 在「把思路变成代码」这一步上效率惊人，但在「决定做什么」和「判断做得对不对」这两步上，依然需要人来把关。

越是底层、越是系统级的编程，这个分工模式越明显。因为底层代码的容错率极低——一个错误的内存操作就是 kernel panic，AI 目前还无法替代人类对系统行为的深层理解。

## 写在最后

如果你也在探索 AI 辅助编程的边界，建议找一个类似的「已知模式移植」项目练手。不一定是内核驱动这么硬核的东西，把一个库从一种语言移植到另一种、把一个 API 从 v1 适配到 v2，这类任务都是 AI 编程的甜区。

关键是理解一点：AI 编程不是让 AI 替你编程，而是**你编程，AI 加速**。

顺便一提，不同 AI 模型在代码生成上的风格和能力差异比你想象的大。想自己体验一下？[OfoxAI](https://ofox.ai)（ofox.ai）聚合了 Claude、GPT、Gemini 等主流模型，一个账号就能对比不同模型的编程表现。
